原文：[Architecture of SQLite](https://www.sqlite.org/arch.html)  
***
# 总览  

![Sqlite的架构](sqlitearch.jpg)
### SQLite的工作方式是将`SQLtext`编译为[bytecode]()，然后使用虚拟机运行该字节码。  
`sqlite3_prepare_v2()`和相关接口充当SQL文本转换成`bytecode`的编译器。  
`sqlite3_stmt`对象是使用实行单一SQL语句的单个字节码程序的容器。  
`sqlite3_step()`接口传递一个`bytecode`程序到虚拟机，并运行该程序。
# 接口(Interface)
### 大多数C语言接口都可以在源文件`main.c`，`legacy.c`和`vdbeapi.c`中找到。 
`sqlite3_get_table()`例程在`table.c`中实现。`sqlite3_mprintf()`在`printf.c`里面可以找到。`sqlite3_complete()`在`complete.c`中。`TCL接口`是在`tclsqlite.c`中。

为了避免名称冲突，SQLite库中的所有外部符号都以前缀`sqlite3`开头。这些供外部使用的符号（换句话说，构成SQLite API的那些符号）添加了一个下划线，因此以`sqlite3_`开头。

扩展API有时会在下划线之前添加扩展名。例如： `sqlite3rbu_`或`sqlite3session_`。  

# 分词器(Tokenizer)
当要解析包含SQL语句的字符串时，首先将其发送到`Tokenizer`里。`Tokenizer`将SQL文本拆分为`tokens`，并将这些`tokens`逐个交给`parser`(解析器)。  
`Tokenizer`可在`tokenizer.c`中找到。

要注意，让`Tokenizer`调用`parser`会更好，因为这样就是线程安全的，而且速度更快。
# 解析器(Parser)
解析器根据令牌的上下文为令牌分配含义。SQLite的解析器是使用 Lemon解析器生成器生成的。Lemon做的工作与YACC / BISON相同，但是它使用不同的输入语法，因此不容易出错。Lemon还生成可重入且线程安全的解析器。并且Lemon定义了非终端析构函数的概念，以便在遇到语法错误时不会泄漏内存。在parse.y中可以找到驱动Lemon并定义SQLite可以理解的SQL语言的语法文件。
因为Lemon是一个通常在开发机器上找不到的程序，所以Lemonite的完整源代码（只有一个C文件）包含在“工具”子目录中的SQLite发行版中。
# 代码生成器
解析器将令牌组装成解析树后，代码生成器将运行以分析解析器树并生成 执行SQL语句工作的字节码。在准备语句对象是此字节码的容器。有许多文件中的代码生成器，包括： attach.c， auth.c， build.c， delete.c， expr.c， insert.c， pragma.c， select.c， trigger.c， update.c， vacuum.c， where.c， wherecode.c和 whereexpr.c。在这些文件中，大多数严重的魔术都在其中发生。 expr.c处理表达式的代码生成。 where * .c处理SELECT，UPDATE和DELETE语句上WHERE子句的代码生成。该文件attach.c， delete.c，insert.c，select.c， trigger.c update.c和vacuum.c处理代码生成具有相同名称的SQL语句。（这些文件中的每个文件都根据需要在expr.c和where.c中调用例程。）所有其他SQL语句都从build.c中进行编码。该auth.c该文件实现sqlite3_set_authorizer()的功能 。
代码生成器，尤其是where * .c 和select.c中的逻辑，有时被称为 查询计划器。对于任何特定的SQL语句，可能有数百，数千或数百万种不同的算法来计算答案。查询计划器是一种AI，致力于从数百万种选择中选择最佳算法。
# 字节码引擎
由代码生成器创建的字节码程序由虚拟机运行。
虚拟机本身完全包含在单个源文件vdbe.c中。所述 vdbe.h头文件定义了虚拟机和SQLite库的其余部分之间的界面 vdbeInt.h其定义了私人虚拟机本身的结构和接口。其他各种vdbe * .c文件都是虚拟机的帮助程序。所述vdbeaux.c文件包含由所用的库的其余部分来构造VM程序在虚拟机和接口模块中使用的工具。所述vdbeapi.c文件包含外部接口到所述虚拟机，如 sqlite3_bind_int()和sqlite3_step()。各个值（字符串，整数，浮点数和BLOB）存储在名为“ Mem”的内部对象中，该对象由vdbemem.c实现 。
SQLite使用对C语言例程的回调来实现SQL函数。甚至内置的SQL函数都是以这种方式实现的。大多数内置SQL函数（例如abs()，count()， substr()等）都可以在func.c源文件中找到。日期和时间转换功能位于date.c中。某些功能（例如coalesce()和typeof()）由代码生成器直接实现为字节码。
# B树
使用在btree.c源文件中找到的B树实现在磁盘上维护SQLite数据库。数据库中的每个表和索引都使用单独的B树。所有B树都存储在同一磁盘文件中。该文件格式的细节是稳定和明确，并保证是向前兼容的移动。
B-tree子系统和其余SQLite库的接口由头文件btree.h定义。
# 页面缓存
B树模块以固定大小的页面从磁盘请求信息。默认的page_size为4096字节，但可以是512到65536字节之间的任意2的幂。页面缓存负责读取，写入和缓存这些页面。页面缓存还提供回滚和原子提交抽象，并负责锁定数据库文件。B树驱动程序从页面缓存中请求特定页面，并在想要修改页面或提交或回滚更改时通知页面缓存。页面缓存处理所有混乱的细节，以确保快速，安全，高效地处理请求。
主页面缓存实现位于 pager.c文件中。 WAL模式逻辑在单独的 wal.c中。内存中缓存由 pcache.c和pcache1.c文件实现。页面缓存子系统和其余SQLite之间的接口由头文件pager.h定义。
# 操作系统界面
为了提供跨操作系统的可移植性，SQLite使用了称为VFS的抽象对象。每个VFS提供了用于打开，读取，写入和关闭磁盘上文件的方法，以及用于其他特定于OS的任务的方法，例如查找当前时间或获取随机性以初始化内置的伪随机数生成器。SQLite当前为UNIX（在os_unix.c 文件中）和Windows（在os_win.c文件中）提供VFS。
# 实用工具
内存分配，无大小写的字符串比较例程，可移植的文本数字转换例程以及其他实用程序位于util.c中。解析器使用的符号表由hash.c中的哈希表维护。该utf.c源文件包含Unicode转换子程序。SQLite的有它自己的私有实现的 ()的printf（标有一些扩展）printf.c并在其自己的伪随机数生成器（PRNG）random.c。
# 测试代码
源树的“ src /”文件夹中名称以test开头的文件 仅用于测试，不包含在库的标准内部版本中。

